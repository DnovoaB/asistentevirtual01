"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/js-base64";
exports.ids = ["vendor-chunks/js-base64"];
exports.modules = {

/***/ "(ssr)/./node_modules/js-base64/base64.js":
/*!******************************************!*\
  !*** ./node_modules/js-base64/base64.js ***!
  \******************************************/
/***/ ((module) => {

eval("//\n// THIS FILE IS AUTOMATICALLY GENERATED! DO NOT EDIT BY HAND!\n//\n\n(function(global1, factory) {\n     true ? module.exports = factory() : 0;\n})(typeof self !== \"undefined\" ? self :  false ? 0 : typeof global !== \"undefined\" ? global : void 0, function() {\n    \"use strict\";\n    /**\n     *  base64.ts\n     *\n     *  Licensed under the BSD 3-Clause License.\n     *    http://opensource.org/licenses/BSD-3-Clause\n     *\n     *  References:\n     *    http://en.wikipedia.org/wiki/Base64\n     *\n     * @author Dan Kogai (https://github.com/dankogai)\n     */ var version = \"3.7.2\";\n    /**\n     * @deprecated use lowercase `version`.\n     */ var VERSION = version;\n    var _hasatob = typeof atob === \"function\";\n    var _hasbtoa = typeof btoa === \"function\";\n    var _hasBuffer = typeof Buffer === \"function\";\n    var _TD = typeof TextDecoder === \"function\" ? new TextDecoder() : undefined;\n    var _TE = typeof TextEncoder === \"function\" ? new TextEncoder() : undefined;\n    var b64ch = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n    var b64chs = Array.prototype.slice.call(b64ch);\n    var b64tab = function(a) {\n        var tab = {};\n        a.forEach(function(c, i) {\n            return tab[c] = i;\n        });\n        return tab;\n    }(b64chs);\n    var b64re = /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/;\n    var _fromCC = String.fromCharCode.bind(String);\n    var _U8Afrom = typeof Uint8Array.from === \"function\" ? Uint8Array.from.bind(Uint8Array) : function(it, fn) {\n        if (fn === void 0) {\n            fn = function(x) {\n                return x;\n            };\n        }\n        return new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));\n    };\n    var _mkUriSafe = function(src) {\n        return src.replace(/=/g, \"\").replace(/[+\\/]/g, function(m0) {\n            return m0 == \"+\" ? \"-\" : \"_\";\n        });\n    };\n    var _tidyB64 = function(s) {\n        return s.replace(/[^A-Za-z0-9\\+\\/]/g, \"\");\n    };\n    /**\n     * polyfill version of `btoa`\n     */ var btoaPolyfill = function(bin) {\n        // console.log('polyfilled');\n        var u32, c0, c1, c2, asc = \"\";\n        var pad = bin.length % 3;\n        for(var i = 0; i < bin.length;){\n            if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255) throw new TypeError(\"invalid character found\");\n            u32 = c0 << 16 | c1 << 8 | c2;\n            asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];\n        }\n        return pad ? asc.slice(0, pad - 3) + \"===\".substring(pad) : asc;\n    };\n    /**\n     * does what `window.btoa` of web browsers do.\n     * @param {String} bin binary string\n     * @returns {string} Base64-encoded string\n     */ var _btoa = _hasbtoa ? function(bin) {\n        return btoa(bin);\n    } : _hasBuffer ? function(bin) {\n        return Buffer.from(bin, \"binary\").toString(\"base64\");\n    } : btoaPolyfill;\n    var _fromUint8Array = _hasBuffer ? function(u8a) {\n        return Buffer.from(u8a).toString(\"base64\");\n    } : function(u8a) {\n        // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326\n        var maxargs = 0x1000;\n        var strs = [];\n        for(var i = 0, l = u8a.length; i < l; i += maxargs){\n            strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));\n        }\n        return _btoa(strs.join(\"\"));\n    };\n    /**\n     * converts a Uint8Array to a Base64 string.\n     * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 ยง5\n     * @returns {string} Base64 string\n     */ var fromUint8Array = function(u8a, urlsafe) {\n        if (urlsafe === void 0) {\n            urlsafe = false;\n        }\n        return urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);\n    };\n    // This trick is found broken https://github.com/dankogai/js-base64/issues/130\n    // const utob = (src: string) => unescape(encodeURIComponent(src));\n    // reverting good old fationed regexp\n    var cb_utob = function(c) {\n        if (c.length < 2) {\n            var cc = c.charCodeAt(0);\n            return cc < 0x80 ? c : cc < 0x800 ? _fromCC(0xc0 | cc >>> 6) + _fromCC(0x80 | cc & 0x3f) : _fromCC(0xe0 | cc >>> 12 & 0x0f) + _fromCC(0x80 | cc >>> 6 & 0x3f) + _fromCC(0x80 | cc & 0x3f);\n        } else {\n            var cc = 0x10000 + (c.charCodeAt(0) - 0xD800) * 0x400 + (c.charCodeAt(1) - 0xDC00);\n            return _fromCC(0xf0 | cc >>> 18 & 0x07) + _fromCC(0x80 | cc >>> 12 & 0x3f) + _fromCC(0x80 | cc >>> 6 & 0x3f) + _fromCC(0x80 | cc & 0x3f);\n        }\n    };\n    var re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n    /**\n     * @deprecated should have been internal use only.\n     * @param {string} src UTF-8 string\n     * @returns {string} UTF-16 string\n     */ var utob = function(u) {\n        return u.replace(re_utob, cb_utob);\n    };\n    //\n    var _encode = _hasBuffer ? function(s) {\n        return Buffer.from(s, \"utf8\").toString(\"base64\");\n    } : _TE ? function(s) {\n        return _fromUint8Array(_TE.encode(s));\n    } : function(s) {\n        return _btoa(utob(s));\n    };\n    /**\n     * converts a UTF-8-encoded string to a Base64 string.\n     * @param {boolean} [urlsafe] if `true` make the result URL-safe\n     * @returns {string} Base64 string\n     */ var encode = function(src, urlsafe) {\n        if (urlsafe === void 0) {\n            urlsafe = false;\n        }\n        return urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);\n    };\n    /**\n     * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 ยง5.\n     * @returns {string} Base64 string\n     */ var encodeURI = function(src) {\n        return encode(src, true);\n    };\n    // This trick is found broken https://github.com/dankogai/js-base64/issues/130\n    // const btou = (src: string) => decodeURIComponent(escape(src));\n    // reverting good old fationed regexp\n    var re_btou = /[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\xBF]{2}|[\\xF0-\\xF7][\\x80-\\xBF]{3}/g;\n    var cb_btou = function(cccc) {\n        switch(cccc.length){\n            case 4:\n                var cp = (0x07 & cccc.charCodeAt(0)) << 18 | (0x3f & cccc.charCodeAt(1)) << 12 | (0x3f & cccc.charCodeAt(2)) << 6 | 0x3f & cccc.charCodeAt(3), offset = cp - 0x10000;\n                return _fromCC((offset >>> 10) + 0xD800) + _fromCC((offset & 0x3FF) + 0xDC00);\n            case 3:\n                return _fromCC((0x0f & cccc.charCodeAt(0)) << 12 | (0x3f & cccc.charCodeAt(1)) << 6 | 0x3f & cccc.charCodeAt(2));\n            default:\n                return _fromCC((0x1f & cccc.charCodeAt(0)) << 6 | 0x3f & cccc.charCodeAt(1));\n        }\n    };\n    /**\n     * @deprecated should have been internal use only.\n     * @param {string} src UTF-16 string\n     * @returns {string} UTF-8 string\n     */ var btou = function(b) {\n        return b.replace(re_btou, cb_btou);\n    };\n    /**\n     * polyfill version of `atob`\n     */ var atobPolyfill = function(asc) {\n        // console.log('polyfilled');\n        asc = asc.replace(/\\s+/g, \"\");\n        if (!b64re.test(asc)) throw new TypeError(\"malformed base64.\");\n        asc += \"==\".slice(2 - (asc.length & 3));\n        var u24, bin = \"\", r1, r2;\n        for(var i = 0; i < asc.length;){\n            u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);\n            bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);\n        }\n        return bin;\n    };\n    /**\n     * does what `window.atob` of web browsers do.\n     * @param {String} asc Base64-encoded string\n     * @returns {string} binary string\n     */ var _atob = _hasatob ? function(asc) {\n        return atob(_tidyB64(asc));\n    } : _hasBuffer ? function(asc) {\n        return Buffer.from(asc, \"base64\").toString(\"binary\");\n    } : atobPolyfill;\n    //\n    var _toUint8Array = _hasBuffer ? function(a) {\n        return _U8Afrom(Buffer.from(a, \"base64\"));\n    } : function(a) {\n        return _U8Afrom(_atob(a), function(c) {\n            return c.charCodeAt(0);\n        });\n    };\n    /**\n     * converts a Base64 string to a Uint8Array.\n     */ var toUint8Array = function(a) {\n        return _toUint8Array(_unURI(a));\n    };\n    //\n    var _decode = _hasBuffer ? function(a) {\n        return Buffer.from(a, \"base64\").toString(\"utf8\");\n    } : _TD ? function(a) {\n        return _TD.decode(_toUint8Array(a));\n    } : function(a) {\n        return btou(_atob(a));\n    };\n    var _unURI = function(a) {\n        return _tidyB64(a.replace(/[-_]/g, function(m0) {\n            return m0 == \"-\" ? \"+\" : \"/\";\n        }));\n    };\n    /**\n     * converts a Base64 string to a UTF-8 string.\n     * @param {String} src Base64 string.  Both normal and URL-safe are supported\n     * @returns {string} UTF-8 string\n     */ var decode = function(src) {\n        return _decode(_unURI(src));\n    };\n    /**\n     * check if a value is a valid Base64 string\n     * @param {String} src a value to check\n      */ var isValid = function(src) {\n        if (typeof src !== \"string\") return false;\n        var s = src.replace(/\\s+/g, \"\").replace(/={0,2}$/, \"\");\n        return !/[^\\s0-9a-zA-Z\\+/]/.test(s) || !/[^\\s0-9a-zA-Z\\-_]/.test(s);\n    };\n    //\n    var _noEnum = function(v) {\n        return {\n            value: v,\n            enumerable: false,\n            writable: true,\n            configurable: true\n        };\n    };\n    /**\n     * extend String.prototype with relevant methods\n     */ var extendString = function() {\n        var _add = function(name, body) {\n            return Object.defineProperty(String.prototype, name, _noEnum(body));\n        };\n        _add(\"fromBase64\", function() {\n            return decode(this);\n        });\n        _add(\"toBase64\", function(urlsafe) {\n            return encode(this, urlsafe);\n        });\n        _add(\"toBase64URI\", function() {\n            return encode(this, true);\n        });\n        _add(\"toBase64URL\", function() {\n            return encode(this, true);\n        });\n        _add(\"toUint8Array\", function() {\n            return toUint8Array(this);\n        });\n    };\n    /**\n     * extend Uint8Array.prototype with relevant methods\n     */ var extendUint8Array = function() {\n        var _add = function(name, body) {\n            return Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));\n        };\n        _add(\"toBase64\", function(urlsafe) {\n            return fromUint8Array(this, urlsafe);\n        });\n        _add(\"toBase64URI\", function() {\n            return fromUint8Array(this, true);\n        });\n        _add(\"toBase64URL\", function() {\n            return fromUint8Array(this, true);\n        });\n    };\n    /**\n     * extend Builtin prototypes with relevant methods\n     */ var extendBuiltins = function() {\n        extendString();\n        extendUint8Array();\n    };\n    var gBase64 = {\n        version: version,\n        VERSION: VERSION,\n        atob: _atob,\n        atobPolyfill: atobPolyfill,\n        btoa: _btoa,\n        btoaPolyfill: btoaPolyfill,\n        fromBase64: decode,\n        toBase64: encode,\n        encode: encode,\n        encodeURI: encodeURI,\n        encodeURL: encodeURI,\n        utob: utob,\n        btou: btou,\n        decode: decode,\n        isValid: isValid,\n        fromUint8Array: fromUint8Array,\n        toUint8Array: toUint8Array,\n        extendString: extendString,\n        extendUint8Array: extendUint8Array,\n        extendBuiltins: extendBuiltins\n    };\n    //\n    // export Base64 to the namespace\n    //\n    // ES5 is yet to have Object.assign() that may make transpilers unhappy.\n    // gBase64.Base64 = Object.assign({}, gBase64);\n    gBase64.Base64 = {};\n    Object.keys(gBase64).forEach(function(k) {\n        return gBase64.Base64[k] = gBase64[k];\n    });\n    return gBase64;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanMtYmFzZTY0L2Jhc2U2NC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxFQUFFO0FBQ0YsNkRBQTZEO0FBQzdELEVBQUU7O0FBRUQsVUFBVUEsT0FBTSxFQUFFQyxPQUFPO0lBQ3RCLEtBQWlELEdBQzNDRSxPQUFPRCxPQUFPLEdBQUdELFlBQ2pCLENBZUU7QUFDWixHQUFHLE9BQU9VLFNBQVMsY0FBY0EsT0FDM0IsTUFBa0IsR0FBY0MsQ0FBTUEsR0FDbEMsT0FBT1osV0FBVyxjQUFjQSxTQUM1QixRQUFPO0lBQ2pCO0lBQ0E7Ozs7Ozs7Ozs7S0FVQyxHQUNELElBQUlhLFVBQVU7SUFDZDs7S0FFQyxHQUNELElBQUlDLFVBQVVEO0lBQ2QsSUFBSUUsV0FBVyxPQUFPQyxTQUFTO0lBQy9CLElBQUlDLFdBQVcsT0FBT0MsU0FBUztJQUMvQixJQUFJQyxhQUFhLE9BQU9DLFdBQVc7SUFDbkMsSUFBSUMsTUFBTSxPQUFPQyxnQkFBZ0IsYUFBYSxJQUFJQSxnQkFBZ0JDO0lBQ2xFLElBQUlDLE1BQU0sT0FBT0MsZ0JBQWdCLGFBQWEsSUFBSUEsZ0JBQWdCRjtJQUNsRSxJQUFJRyxRQUFRO0lBQ1osSUFBSUMsU0FBU0MsTUFBTUMsU0FBUyxDQUFDQyxLQUFLLENBQUNDLElBQUksQ0FBQ0w7SUFDeEMsSUFBSU0sU0FBUyxTQUFXQyxDQUFDO1FBQ3JCLElBQUlDLE1BQU0sQ0FBQztRQUNYRCxFQUFFRSxPQUFPLENBQUMsU0FBVUMsQ0FBQyxFQUFFQyxDQUFDO1lBQUksT0FBT0gsR0FBRyxDQUFDRSxFQUFFLEdBQUdDO1FBQUc7UUFDL0MsT0FBT0g7SUFDWCxFQUFHUDtJQUNILElBQUlXLFFBQVE7SUFDWixJQUFJQyxVQUFVQyxPQUFPQyxZQUFZLENBQUNDLElBQUksQ0FBQ0Y7SUFDdkMsSUFBSUcsV0FBVyxPQUFPQyxXQUFXQyxJQUFJLEtBQUssYUFDcENELFdBQVdDLElBQUksQ0FBQ0gsSUFBSSxDQUFDRSxjQUNyQixTQUFVRSxFQUFFLEVB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SUFDakMsRUFBRTtJQUNGLHdFQUF3RTtJQUN4RSwrQ0FBK0M7SUFDL0NsSCxRQUFRRCxNQUFNLEdBQUcsQ0FBQztJQUNsQmdILE9BQU9PLElBQUksQ0FBQ3RILFNBQVMyQixPQUFPLENBQUMsU0FBVTRGLENBQUM7UUFBSSxPQUFPdkgsUUFBUUQsTUFBTSxDQUFDd0gsRUFBRSxHQUFHdkgsT0FBTyxDQUFDdUgsRUFBRTtJQUFFO0lBQ25GLE9BQU92SDtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXNpc3RlbnRlLXZpcnR1YWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvanMtYmFzZTY0L2Jhc2U2NC5qcz8xOWQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vXG4vLyBUSElTIEZJTEUgSVMgQVVUT01BVElDQUxMWSBHRU5FUkFURUQhIERPIE5PVCBFRElUIEJZIEhBTkQhXG4vL1xuO1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKVxuICAgICAgICA6IHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZFxuICAgICAgICAgICAgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgICAgICAgICAgLy8gY2YuIGh0dHBzOi8vZ2l0aHViLmNvbS9kYW5rb2dhaS9qcy1iYXNlNjQvaXNzdWVzLzExOVxuICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBleGlzdGluZyB2ZXJzaW9uIGZvciBub0NvbmZsaWN0KClcbiAgICAgICAgICAgICAgICB2YXIgX0Jhc2U2NCA9IGdsb2JhbC5CYXNlNjQ7XG4gICAgICAgICAgICAgICAgdmFyIGdCYXNlNjQgPSBmYWN0b3J5KCk7XG4gICAgICAgICAgICAgICAgZ0Jhc2U2NC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWwuQmFzZTY0ID0gX0Jhc2U2NDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdCYXNlNjQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoZ2xvYmFsLk1ldGVvcikgeyAvLyBNZXRlb3IuanNcbiAgICAgICAgICAgICAgICAgICAgQmFzZTY0ID0gZ0Jhc2U2NDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2xvYmFsLkJhc2U2NCA9IGdCYXNlNjQ7XG4gICAgICAgICAgICB9KSgpO1xufSgodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZlxuICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3dcbiAgICAgICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFxuICAgICAgICAgICAgOiB0aGlzKSwgZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAgKiAgYmFzZTY0LnRzXG4gICAgICpcbiAgICAgKiAgTGljZW5zZWQgdW5kZXIgdGhlIEJTRCAzLUNsYXVzZSBMaWNlbnNlLlxuICAgICAqICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAgICAgKlxuICAgICAqICBSZWZlcmVuY2VzOlxuICAgICAqICAgIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIERhbiBLb2dhaSAoaHR0cHM6Ly9naXRodWIuY29tL2RhbmtvZ2FpKVxuICAgICAqL1xuICAgIHZhciB2ZXJzaW9uID0gJzMuNy4yJztcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCB1c2UgbG93ZXJjYXNlIGB2ZXJzaW9uYC5cbiAgICAgKi9cbiAgICB2YXIgVkVSU0lPTiA9IHZlcnNpb247XG4gICAgdmFyIF9oYXNhdG9iID0gdHlwZW9mIGF0b2IgPT09ICdmdW5jdGlvbic7XG4gICAgdmFyIF9oYXNidG9hID0gdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbic7XG4gICAgdmFyIF9oYXNCdWZmZXIgPSB0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nO1xuICAgIHZhciBfVEQgPSB0eXBlb2YgVGV4dERlY29kZXIgPT09ICdmdW5jdGlvbicgPyBuZXcgVGV4dERlY29kZXIoKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgX1RFID0gdHlwZW9mIFRleHRFbmNvZGVyID09PSAnZnVuY3Rpb24nID8gbmV3IFRleHRFbmNvZGVyKCkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGI2NGNoID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcbiAgICB2YXIgYjY0Y2hzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYjY0Y2gpO1xuICAgIHZhciBiNjR0YWIgPSAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHRhYiA9IHt9O1xuICAgICAgICBhLmZvckVhY2goZnVuY3Rpb24gKGMsIGkpIHsgcmV0dXJuIHRhYltjXSA9IGk7IH0pO1xuICAgICAgICByZXR1cm4gdGFiO1xuICAgIH0pKGI2NGNocyk7XG4gICAgdmFyIGI2NHJlID0gL14oPzpbQS1aYS16XFxkK1xcL117NH0pKj8oPzpbQS1aYS16XFxkK1xcL117Mn0oPzo9PSk/fFtBLVphLXpcXGQrXFwvXXszfT0/KT8kLztcbiAgICB2YXIgX2Zyb21DQyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYmluZChTdHJpbmcpO1xuICAgIHZhciBfVThBZnJvbSA9IHR5cGVvZiBVaW50OEFycmF5LmZyb20gPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBVaW50OEFycmF5LmZyb20uYmluZChVaW50OEFycmF5KVxuICAgICAgICA6IGZ1bmN0aW9uIChpdCwgZm4pIHtcbiAgICAgICAgICAgIGlmIChmbiA9PT0gdm9pZCAwKSB7IGZuID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH07IH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpdCwgMCkubWFwKGZuKSk7XG4gICAgICAgIH07XG4gICAgdmFyIF9ta1VyaVNhZmUgPSBmdW5jdGlvbiAoc3JjKSB7IHJldHVybiBzcmNcbiAgICAgICAgLnJlcGxhY2UoLz0vZywgJycpLnJlcGxhY2UoL1srXFwvXS9nLCBmdW5jdGlvbiAobTApIHsgcmV0dXJuIG0wID09ICcrJyA/ICctJyA6ICdfJzsgfSk7IH07XG4gICAgdmFyIF90aWR5QjY0ID0gZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9dL2csICcnKTsgfTtcbiAgICAvKipcbiAgICAgKiBwb2x5ZmlsbCB2ZXJzaW9uIG9mIGBidG9hYFxuICAgICAqL1xuICAgIHZhciBidG9hUG9seWZpbGwgPSBmdW5jdGlvbiAoYmluKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdwb2x5ZmlsbGVkJyk7XG4gICAgICAgIHZhciB1MzIsIGMwLCBjMSwgYzIsIGFzYyA9ICcnO1xuICAgICAgICB2YXIgcGFkID0gYmluLmxlbmd0aCAlIDM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmluLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGlmICgoYzAgPSBiaW4uY2hhckNvZGVBdChpKyspKSA+IDI1NSB8fFxuICAgICAgICAgICAgICAgIChjMSA9IGJpbi5jaGFyQ29kZUF0KGkrKykpID4gMjU1IHx8XG4gICAgICAgICAgICAgICAgKGMyID0gYmluLmNoYXJDb2RlQXQoaSsrKSkgPiAyNTUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBjaGFyYWN0ZXIgZm91bmQnKTtcbiAgICAgICAgICAgIHUzMiA9IChjMCA8PCAxNikgfCAoYzEgPDwgOCkgfCBjMjtcbiAgICAgICAgICAgIGFzYyArPSBiNjRjaHNbdTMyID4+IDE4ICYgNjNdXG4gICAgICAgICAgICAgICAgKyBiNjRjaHNbdTMyID4+IDEyICYgNjNdXG4gICAgICAgICAgICAgICAgKyBiNjRjaHNbdTMyID4+IDYgJiA2M11cbiAgICAgICAgICAgICAgICArIGI2NGNoc1t1MzIgJiA2M107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhZCA/IGFzYy5zbGljZSgwLCBwYWQgLSAzKSArIFwiPT09XCIuc3Vic3RyaW5nKHBhZCkgOiBhc2M7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBkb2VzIHdoYXQgYHdpbmRvdy5idG9hYCBvZiB3ZWIgYnJvd3NlcnMgZG8uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGJpbiBiaW5hcnkgc3RyaW5nXG4gICAgICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0LWVuY29kZWQgc3RyaW5nXG4gICAgICovXG4gICAgdmFyIF9idG9hID0gX2hhc2J0b2EgPyBmdW5jdGlvbiAoYmluKSB7IHJldHVybiBidG9hKGJpbik7IH1cbiAgICAgICAgOiBfaGFzQnVmZmVyID8gZnVuY3Rpb24gKGJpbikgeyByZXR1cm4gQnVmZmVyLmZyb20oYmluLCAnYmluYXJ5JykudG9TdHJpbmcoJ2Jhc2U2NCcpOyB9XG4gICAgICAgICAgICA6IGJ0b2FQb2x5ZmlsbDtcbiAgICB2YXIgX2Zyb21VaW50OEFycmF5ID0gX2hhc0J1ZmZlclxuICAgICAgICA/IGZ1bmN0aW9uICh1OGEpIHsgcmV0dXJuIEJ1ZmZlci5mcm9tKHU4YSkudG9TdHJpbmcoJ2Jhc2U2NCcpOyB9XG4gICAgICAgIDogZnVuY3Rpb24gKHU4YSkge1xuICAgICAgICAgICAgLy8gY2YuIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEyNzEwMDAxL2hvdy10by1jb252ZXJ0LXVpbnQ4LWFycmF5LXRvLWJhc2U2NC1lbmNvZGVkLXN0cmluZy8xMjcxMzMyNiMxMjcxMzMyNlxuICAgICAgICAgICAgdmFyIG1heGFyZ3MgPSAweDEwMDA7XG4gICAgICAgICAgICB2YXIgc3RycyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB1OGEubGVuZ3RoOyBpIDwgbDsgaSArPSBtYXhhcmdzKSB7XG4gICAgICAgICAgICAgICAgc3Rycy5wdXNoKF9mcm9tQ0MuYXBwbHkobnVsbCwgdThhLnN1YmFycmF5KGksIGkgKyBtYXhhcmdzKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9idG9hKHN0cnMuam9pbignJykpO1xuICAgICAgICB9O1xuICAgIC8qKlxuICAgICAqIGNvbnZlcnRzIGEgVWludDhBcnJheSB0byBhIEJhc2U2NCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbdXJsc2FmZV0gVVJMLWFuZC1maWxlbmFtZS1zYWZlIGEgbGEgUkZDNDY0OCDCpzVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlNjQgc3RyaW5nXG4gICAgICovXG4gICAgdmFyIGZyb21VaW50OEFycmF5ID0gZnVuY3Rpb24gKHU4YSwgdXJsc2FmZSkge1xuICAgICAgICBpZiAodXJsc2FmZSA9PT0gdm9pZCAwKSB7IHVybHNhZmUgPSBmYWxzZTsgfVxuICAgICAgICByZXR1cm4gdXJsc2FmZSA/IF9ta1VyaVNhZmUoX2Zyb21VaW50OEFycmF5KHU4YSkpIDogX2Zyb21VaW50OEFycmF5KHU4YSk7XG4gICAgfTtcbiAgICAvLyBUaGlzIHRyaWNrIGlzIGZvdW5kIGJyb2tlbiBodHRwczovL2dpdGh1Yi5jb20vZGFua29nYWkvanMtYmFzZTY0L2lzc3Vlcy8xMzBcbiAgICAvLyBjb25zdCB1dG9iID0gKHNyYzogc3RyaW5nKSA9PiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3JjKSk7XG4gICAgLy8gcmV2ZXJ0aW5nIGdvb2Qgb2xkIGZhdGlvbmVkIHJlZ2V4cFxuICAgIHZhciBjYl91dG9iID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgdmFyIGNjID0gYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgcmV0dXJuIGNjIDwgMHg4MCA/IGNcbiAgICAgICAgICAgICAgICA6IGNjIDwgMHg4MDAgPyAoX2Zyb21DQygweGMwIHwgKGNjID4+PiA2KSlcbiAgICAgICAgICAgICAgICAgICAgKyBfZnJvbUNDKDB4ODAgfCAoY2MgJiAweDNmKSkpXG4gICAgICAgICAgICAgICAgICAgIDogKF9mcm9tQ0MoMHhlMCB8ICgoY2MgPj4+IDEyKSAmIDB4MGYpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBfZnJvbUNDKDB4ODAgfCAoKGNjID4+PiA2KSAmIDB4M2YpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBfZnJvbUNDKDB4ODAgfCAoY2MgJiAweDNmKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNjID0gMHgxMDAwMFxuICAgICAgICAgICAgICAgICsgKGMuY2hhckNvZGVBdCgwKSAtIDB4RDgwMCkgKiAweDQwMFxuICAgICAgICAgICAgICAgICsgKGMuY2hhckNvZGVBdCgxKSAtIDB4REMwMCk7XG4gICAgICAgICAgICByZXR1cm4gKF9mcm9tQ0MoMHhmMCB8ICgoY2MgPj4+IDE4KSAmIDB4MDcpKVxuICAgICAgICAgICAgICAgICsgX2Zyb21DQygweDgwIHwgKChjYyA+Pj4gMTIpICYgMHgzZikpXG4gICAgICAgICAgICAgICAgKyBfZnJvbUNDKDB4ODAgfCAoKGNjID4+PiA2KSAmIDB4M2YpKVxuICAgICAgICAgICAgICAgICsgX2Zyb21DQygweDgwIHwgKGNjICYgMHgzZikpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlX3V0b2IgPSAvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGRl18W15cXHgwMC1cXHg3Rl0vZztcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBzaG91bGQgaGF2ZSBiZWVuIGludGVybmFsIHVzZSBvbmx5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgVVRGLTggc3RyaW5nXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVVRGLTE2IHN0cmluZ1xuICAgICAqL1xuICAgIHZhciB1dG9iID0gZnVuY3Rpb24gKHUpIHsgcmV0dXJuIHUucmVwbGFjZShyZV91dG9iLCBjYl91dG9iKTsgfTtcbiAgICAvL1xuICAgIHZhciBfZW5jb2RlID0gX2hhc0J1ZmZlclxuICAgICAgICA/IGZ1bmN0aW9uIChzKSB7IHJldHVybiBCdWZmZXIuZnJvbShzLCAndXRmOCcpLnRvU3RyaW5nKCdiYXNlNjQnKTsgfVxuICAgICAgICA6IF9URVxuICAgICAgICAgICAgPyBmdW5jdGlvbiAocykgeyByZXR1cm4gX2Zyb21VaW50OEFycmF5KF9URS5lbmNvZGUocykpOyB9XG4gICAgICAgICAgICA6IGZ1bmN0aW9uIChzKSB7IHJldHVybiBfYnRvYSh1dG9iKHMpKTsgfTtcbiAgICAvKipcbiAgICAgKiBjb252ZXJ0cyBhIFVURi04LWVuY29kZWQgc3RyaW5nIHRvIGEgQmFzZTY0IHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1cmxzYWZlXSBpZiBgdHJ1ZWAgbWFrZSB0aGUgcmVzdWx0IFVSTC1zYWZlXG4gICAgICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0IHN0cmluZ1xuICAgICAqL1xuICAgIHZhciBlbmNvZGUgPSBmdW5jdGlvbiAoc3JjLCB1cmxzYWZlKSB7XG4gICAgICAgIGlmICh1cmxzYWZlID09PSB2b2lkIDApIHsgdXJsc2FmZSA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiB1cmxzYWZlXG4gICAgICAgICAgICA/IF9ta1VyaVNhZmUoX2VuY29kZShzcmMpKVxuICAgICAgICAgICAgOiBfZW5jb2RlKHNyYyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBjb252ZXJ0cyBhIFVURi04LWVuY29kZWQgc3RyaW5nIHRvIFVSTC1zYWZlIEJhc2U2NCBSRkM0NjQ4IMKnNS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlNjQgc3RyaW5nXG4gICAgICovXG4gICAgdmFyIGVuY29kZVVSSSA9IGZ1bmN0aW9uIChzcmMpIHsgcmV0dXJuIGVuY29kZShzcmMsIHRydWUpOyB9O1xuICAgIC8vIFRoaXMgdHJpY2sgaXMgZm91bmQgYnJva2VuIGh0dHBzOi8vZ2l0aHViLmNvbS9kYW5rb2dhaS9qcy1iYXNlNjQvaXNzdWVzLzEzMFxuICAgIC8vIGNvbnN0IGJ0b3UgPSAoc3JjOiBzdHJpbmcpID0+IGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoc3JjKSk7XG4gICAgLy8gcmV2ZXJ0aW5nIGdvb2Qgb2xkIGZhdGlvbmVkIHJlZ2V4cFxuICAgIHZhciByZV9idG91ID0gL1tcXHhDMC1cXHhERl1bXFx4ODAtXFx4QkZdfFtcXHhFMC1cXHhFRl1bXFx4ODAtXFx4QkZdezJ9fFtcXHhGMC1cXHhGN11bXFx4ODAtXFx4QkZdezN9L2c7XG4gICAgdmFyIGNiX2J0b3UgPSBmdW5jdGlvbiAoY2NjYykge1xuICAgICAgICBzd2l0Y2ggKGNjY2MubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgdmFyIGNwID0gKCgweDA3ICYgY2NjYy5jaGFyQ29kZUF0KDApKSA8PCAxOClcbiAgICAgICAgICAgICAgICAgICAgfCAoKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMSkpIDw8IDEyKVxuICAgICAgICAgICAgICAgICAgICB8ICgoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgyKSkgPDwgNilcbiAgICAgICAgICAgICAgICAgICAgfCAoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgzKSksIG9mZnNldCA9IGNwIC0gMHgxMDAwMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gKF9mcm9tQ0MoKG9mZnNldCA+Pj4gMTApICsgMHhEODAwKVxuICAgICAgICAgICAgICAgICAgICArIF9mcm9tQ0MoKG9mZnNldCAmIDB4M0ZGKSArIDB4REMwMCkpO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJvbUNDKCgoMHgwZiAmIGNjY2MuY2hhckNvZGVBdCgwKSkgPDwgMTIpXG4gICAgICAgICAgICAgICAgICAgIHwgKCgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDEpKSA8PCA2KVxuICAgICAgICAgICAgICAgICAgICB8ICgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDIpKSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJvbUNDKCgoMHgxZiAmIGNjY2MuY2hhckNvZGVBdCgwKSkgPDwgNilcbiAgICAgICAgICAgICAgICAgICAgfCAoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgxKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBzaG91bGQgaGF2ZSBiZWVuIGludGVybmFsIHVzZSBvbmx5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgVVRGLTE2IHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFVURi04IHN0cmluZ1xuICAgICAqL1xuICAgIHZhciBidG91ID0gZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGIucmVwbGFjZShyZV9idG91LCBjYl9idG91KTsgfTtcbiAgICAvKipcbiAgICAgKiBwb2x5ZmlsbCB2ZXJzaW9uIG9mIGBhdG9iYFxuICAgICAqL1xuICAgIHZhciBhdG9iUG9seWZpbGwgPSBmdW5jdGlvbiAoYXNjKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdwb2x5ZmlsbGVkJyk7XG4gICAgICAgIGFzYyA9IGFzYy5yZXBsYWNlKC9cXHMrL2csICcnKTtcbiAgICAgICAgaWYgKCFiNjRyZS50ZXN0KGFzYykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYWxmb3JtZWQgYmFzZTY0LicpO1xuICAgICAgICBhc2MgKz0gJz09Jy5zbGljZSgyIC0gKGFzYy5sZW5ndGggJiAzKSk7XG4gICAgICAgIHZhciB1MjQsIGJpbiA9ICcnLCByMSwgcjI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXNjLmxlbmd0aDspIHtcbiAgICAgICAgICAgIHUyNCA9IGI2NHRhYlthc2MuY2hhckF0KGkrKyldIDw8IDE4XG4gICAgICAgICAgICAgICAgfCBiNjR0YWJbYXNjLmNoYXJBdChpKyspXSA8PCAxMlxuICAgICAgICAgICAgICAgIHwgKHIxID0gYjY0dGFiW2FzYy5jaGFyQXQoaSsrKV0pIDw8IDZcbiAgICAgICAgICAgICAgICB8IChyMiA9IGI2NHRhYlthc2MuY2hhckF0KGkrKyldKTtcbiAgICAgICAgICAgIGJpbiArPSByMSA9PT0gNjQgPyBfZnJvbUNDKHUyNCA+PiAxNiAmIDI1NSlcbiAgICAgICAgICAgICAgICA6IHIyID09PSA2NCA/IF9mcm9tQ0ModTI0ID4+IDE2ICYgMjU1LCB1MjQgPj4gOCAmIDI1NSlcbiAgICAgICAgICAgICAgICAgICAgOiBfZnJvbUNDKHUyNCA+PiAxNiAmIDI1NSwgdTI0ID4+IDggJiAyNTUsIHUyNCAmIDI1NSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGRvZXMgd2hhdCBgd2luZG93LmF0b2JgIG9mIHdlYiBicm93c2VycyBkby5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXNjIEJhc2U2NC1lbmNvZGVkIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGJpbmFyeSBzdHJpbmdcbiAgICAgKi9cbiAgICB2YXIgX2F0b2IgPSBfaGFzYXRvYiA/IGZ1bmN0aW9uIChhc2MpIHsgcmV0dXJuIGF0b2IoX3RpZHlCNjQoYXNjKSk7IH1cbiAgICAgICAgOiBfaGFzQnVmZmVyID8gZnVuY3Rpb24gKGFzYykgeyByZXR1cm4gQnVmZmVyLmZyb20oYXNjLCAnYmFzZTY0JykudG9TdHJpbmcoJ2JpbmFyeScpOyB9XG4gICAgICAgICAgICA6IGF0b2JQb2x5ZmlsbDtcbiAgICAvL1xuICAgIHZhciBfdG9VaW50OEFycmF5ID0gX2hhc0J1ZmZlclxuICAgICAgICA/IGZ1bmN0aW9uIChhKSB7IHJldHVybiBfVThBZnJvbShCdWZmZXIuZnJvbShhLCAnYmFzZTY0JykpOyB9XG4gICAgICAgIDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIF9VOEFmcm9tKF9hdG9iKGEpLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5jaGFyQ29kZUF0KDApOyB9KTsgfTtcbiAgICAvKipcbiAgICAgKiBjb252ZXJ0cyBhIEJhc2U2NCBzdHJpbmcgdG8gYSBVaW50OEFycmF5LlxuICAgICAqL1xuICAgIHZhciB0b1VpbnQ4QXJyYXkgPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gX3RvVWludDhBcnJheShfdW5VUkkoYSkpOyB9O1xuICAgIC8vXG4gICAgdmFyIF9kZWNvZGUgPSBfaGFzQnVmZmVyXG4gICAgICAgID8gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIEJ1ZmZlci5mcm9tKGEsICdiYXNlNjQnKS50b1N0cmluZygndXRmOCcpOyB9XG4gICAgICAgIDogX1REXG4gICAgICAgICAgICA/IGZ1bmN0aW9uIChhKSB7IHJldHVybiBfVEQuZGVjb2RlKF90b1VpbnQ4QXJyYXkoYSkpOyB9XG4gICAgICAgICAgICA6IGZ1bmN0aW9uIChhKSB7IHJldHVybiBidG91KF9hdG9iKGEpKTsgfTtcbiAgICB2YXIgX3VuVVJJID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIF90aWR5QjY0KGEucmVwbGFjZSgvWy1fXS9nLCBmdW5jdGlvbiAobTApIHsgcmV0dXJuIG0wID09ICctJyA/ICcrJyA6ICcvJzsgfSkpOyB9O1xuICAgIC8qKlxuICAgICAqIGNvbnZlcnRzIGEgQmFzZTY0IHN0cmluZyB0byBhIFVURi04IHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjIEJhc2U2NCBzdHJpbmcuICBCb3RoIG5vcm1hbCBhbmQgVVJMLXNhZmUgYXJlIHN1cHBvcnRlZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFVURi04IHN0cmluZ1xuICAgICAqL1xuICAgIHZhciBkZWNvZGUgPSBmdW5jdGlvbiAoc3JjKSB7IHJldHVybiBfZGVjb2RlKF91blVSSShzcmMpKTsgfTtcbiAgICAvKipcbiAgICAgKiBjaGVjayBpZiBhIHZhbHVlIGlzIGEgdmFsaWQgQmFzZTY0IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgYSB2YWx1ZSB0byBjaGVja1xuICAgICAgKi9cbiAgICB2YXIgaXNWYWxpZCA9IGZ1bmN0aW9uIChzcmMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzcmMgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgcyA9IHNyYy5yZXBsYWNlKC9cXHMrL2csICcnKS5yZXBsYWNlKC89ezAsMn0kLywgJycpO1xuICAgICAgICByZXR1cm4gIS9bXlxcczAtOWEtekEtWlxcKy9dLy50ZXN0KHMpIHx8ICEvW15cXHMwLTlhLXpBLVpcXC1fXS8udGVzdChzKTtcbiAgICB9O1xuICAgIC8vXG4gICAgdmFyIF9ub0VudW0gPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHYsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBleHRlbmQgU3RyaW5nLnByb3RvdHlwZSB3aXRoIHJlbGV2YW50IG1ldGhvZHNcbiAgICAgKi9cbiAgICB2YXIgZXh0ZW5kU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2FkZCA9IGZ1bmN0aW9uIChuYW1lLCBib2R5KSB7IHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyaW5nLnByb3RvdHlwZSwgbmFtZSwgX25vRW51bShib2R5KSk7IH07XG4gICAgICAgIF9hZGQoJ2Zyb21CYXNlNjQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGUodGhpcyk7IH0pO1xuICAgICAgICBfYWRkKCd0b0Jhc2U2NCcsIGZ1bmN0aW9uICh1cmxzYWZlKSB7IHJldHVybiBlbmNvZGUodGhpcywgdXJsc2FmZSk7IH0pO1xuICAgICAgICBfYWRkKCd0b0Jhc2U2NFVSSScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZSh0aGlzLCB0cnVlKTsgfSk7XG4gICAgICAgIF9hZGQoJ3RvQmFzZTY0VVJMJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RlKHRoaXMsIHRydWUpOyB9KTtcbiAgICAgICAgX2FkZCgndG9VaW50OEFycmF5JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gdG9VaW50OEFycmF5KHRoaXMpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGV4dGVuZCBVaW50OEFycmF5LnByb3RvdHlwZSB3aXRoIHJlbGV2YW50IG1ldGhvZHNcbiAgICAgKi9cbiAgICB2YXIgZXh0ZW5kVWludDhBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hZGQgPSBmdW5jdGlvbiAobmFtZSwgYm9keSkgeyByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KFVpbnQ4QXJyYXkucHJvdG90eXBlLCBuYW1lLCBfbm9FbnVtKGJvZHkpKTsgfTtcbiAgICAgICAgX2FkZCgndG9CYXNlNjQnLCBmdW5jdGlvbiAodXJsc2FmZSkgeyByZXR1cm4gZnJvbVVpbnQ4QXJyYXkodGhpcywgdXJsc2FmZSk7IH0pO1xuICAgICAgICBfYWRkKCd0b0Jhc2U2NFVSSScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyb21VaW50OEFycmF5KHRoaXMsIHRydWUpOyB9KTtcbiAgICAgICAgX2FkZCgndG9CYXNlNjRVUkwnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBmcm9tVWludDhBcnJheSh0aGlzLCB0cnVlKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBleHRlbmQgQnVpbHRpbiBwcm90b3R5cGVzIHdpdGggcmVsZXZhbnQgbWV0aG9kc1xuICAgICAqL1xuICAgIHZhciBleHRlbmRCdWlsdGlucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZXh0ZW5kU3RyaW5nKCk7XG4gICAgICAgIGV4dGVuZFVpbnQ4QXJyYXkoKTtcbiAgICB9O1xuICAgIHZhciBnQmFzZTY0ID0ge1xuICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICAgICAgICBWRVJTSU9OOiBWRVJTSU9OLFxuICAgICAgICBhdG9iOiBfYXRvYixcbiAgICAgICAgYXRvYlBvbHlmaWxsOiBhdG9iUG9seWZpbGwsXG4gICAgICAgIGJ0b2E6IF9idG9hLFxuICAgICAgICBidG9hUG9seWZpbGw6IGJ0b2FQb2x5ZmlsbCxcbiAgICAgICAgZnJvbUJhc2U2NDogZGVjb2RlLFxuICAgICAgICB0b0Jhc2U2NDogZW5jb2RlLFxuICAgICAgICBlbmNvZGU6IGVuY29kZSxcbiAgICAgICAgZW5jb2RlVVJJOiBlbmNvZGVVUkksXG4gICAgICAgIGVuY29kZVVSTDogZW5jb2RlVVJJLFxuICAgICAgICB1dG9iOiB1dG9iLFxuICAgICAgICBidG91OiBidG91LFxuICAgICAgICBkZWNvZGU6IGRlY29kZSxcbiAgICAgICAgaXNWYWxpZDogaXNWYWxpZCxcbiAgICAgICAgZnJvbVVpbnQ4QXJyYXk6IGZyb21VaW50OEFycmF5LFxuICAgICAgICB0b1VpbnQ4QXJyYXk6IHRvVWludDhBcnJheSxcbiAgICAgICAgZXh0ZW5kU3RyaW5nOiBleHRlbmRTdHJpbmcsXG4gICAgICAgIGV4dGVuZFVpbnQ4QXJyYXk6IGV4dGVuZFVpbnQ4QXJyYXksXG4gICAgICAgIGV4dGVuZEJ1aWx0aW5zOiBleHRlbmRCdWlsdGluc1xuICAgIH07XG4gICAgLy9cbiAgICAvLyBleHBvcnQgQmFzZTY0IHRvIHRoZSBuYW1lc3BhY2VcbiAgICAvL1xuICAgIC8vIEVTNSBpcyB5ZXQgdG8gaGF2ZSBPYmplY3QuYXNzaWduKCkgdGhhdCBtYXkgbWFrZSB0cmFuc3BpbGVycyB1bmhhcHB5LlxuICAgIC8vIGdCYXNlNjQuQmFzZTY0ID0gT2JqZWN0LmFzc2lnbih7fSwgZ0Jhc2U2NCk7XG4gICAgZ0Jhc2U2NC5CYXNlNjQgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhnQmFzZTY0KS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IHJldHVybiBnQmFzZTY0LkJhc2U2NFtrXSA9IGdCYXNlNjRba107IH0pO1xuICAgIHJldHVybiBnQmFzZTY0O1xufSkpO1xuIl0sIm5hbWVzIjpbImdsb2JhbCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwiYW1kIiwiX0Jhc2U2NCIsIkJhc2U2NCIsImdCYXNlNjQiLCJub0NvbmZsaWN0IiwiTWV0ZW9yIiwic2VsZiIsIndpbmRvdyIsInZlcnNpb24iLCJWRVJTSU9OIiwiX2hhc2F0b2IiLCJhdG9iIiwiX2hhc2J0b2EiLCJidG9hIiwiX2hhc0J1ZmZlciIsIkJ1ZmZlciIsIl9URCIsIlRleHREZWNvZGVyIiwidW5kZWZpbmVkIiwiX1RFIiwiVGV4dEVuY29kZXIiLCJiNjRjaCIsImI2NGNocyIsIkFycmF5IiwicHJvdG90eXBlIiwic2xpY2UiLCJjYWxsIiwiYjY0dGFiIiwiYSIsInRhYiIsImZvckVhY2giLCJjIiwiaSIsImI2NHJlIiwiX2Zyb21DQyIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImJpbmQiLCJfVThBZnJvbSIsIlVpbnQ4QXJyYXkiLCJmcm9tIiwiaXQiLCJmbiIsIngiLCJtYXAiLCJfbWtVcmlTYWZlIiwic3JjIiwicmVwbGFjZSIsIm0wIiwiX3RpZHlCNjQiLCJzIiwiYnRvYVBvbHlmaWxsIiwiYmluIiwidTMyIiwiYzAiLCJjMSIsImMyIiwiYXNjIiwicGFkIiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsIlR5cGVFcnJvciIsInN1YnN0cmluZyIsIl9idG9hIiwidG9TdHJpbmciLCJfZnJvbVVpbnQ4QXJyYXkiLCJ1OGEiLCJtYXhhcmdzIiwic3RycyIsImwiLCJwdXNoIiwiYXBwbHkiLCJzdWJhcnJheSIsImpvaW4iLCJmcm9tVWludDhBcnJheSIsInVybHNhZmUiLCJjYl91dG9iIiwiY2MiLCJyZV91dG9iIiwidXRvYiIsInUiLCJfZW5jb2RlIiwiZW5jb2RlIiwiZW5jb2RlVVJJIiwicmVfYnRvdSIsImNiX2J0b3UiLCJjY2NjIiwiY3AiLCJvZmZzZXQiLCJidG91IiwiYiIsImF0b2JQb2x5ZmlsbCIsInRlc3QiLCJ1MjQiLCJyMSIsInIyIiwiY2hhckF0IiwiX2F0b2IiLCJfdG9VaW50OEFycmF5IiwidG9VaW50OEFycmF5IiwiX3VuVVJJIiwiX2RlY29kZSIsImRlY29kZSIsImlzVmFsaWQiLCJfbm9FbnVtIiwidiIsInZhbHVlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZXh0ZW5kU3RyaW5nIiwiX2FkZCIsIm5hbWUiLCJib2R5IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHRlbmRVaW50OEFycmF5IiwiZXh0ZW5kQnVpbHRpbnMiLCJmcm9tQmFzZTY0IiwidG9CYXNlNjQiLCJlbmNvZGVVUkwiLCJrZXlzIiwiayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/js-base64/base64.js\n");

/***/ })

};
;