"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/form-data-encoder";
exports.ids = ["vendor-chunks/form-data-encoder"];
exports.modules = {

/***/ "(ssr)/./node_modules/form-data-encoder/lib/index.cjs":
/*!******************************************************!*\
  !*** ./node_modules/form-data-encoder/lib/index.cjs ***!
  \******************************************************/
/***/ ((module) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\nvar __copyProps = (to, from, except, desc)=>{\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n            get: ()=>from[key],\n            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n    }\n    return to;\n};\nvar __toCommonJS = (mod)=>__copyProps(__defProp({}, \"__esModule\", {\n        value: true\n    }), mod);\nvar __accessCheck = (obj, member, msg)=>{\n    if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter)=>{\n    __accessCheck(obj, member, \"read from private field\");\n    return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value)=>{\n    if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter)=>{\n    __accessCheck(obj, member, \"write to private field\");\n    setter ? setter.call(obj, value) : member.set(obj, value);\n    return value;\n};\nvar __privateMethod = (obj, member, method)=>{\n    __accessCheck(obj, member, \"access private method\");\n    return method;\n};\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n    FormDataEncoder: ()=>FormDataEncoder,\n    isFile: ()=>isFile,\n    isFormData: ()=>isFormData\n});\nmodule.exports = __toCommonJS(src_exports);\n// src/util/isFunction.ts\nvar isFunction = (value)=>typeof value === \"function\";\n// src/util/isAsyncIterable.ts\nvar isAsyncIterable = (value)=>isFunction(value[Symbol.asyncIterator]);\n// src/util/chunk.ts\nvar MAX_CHUNK_SIZE = 65536;\nfunction* chunk(value) {\n    if (value.byteLength <= MAX_CHUNK_SIZE) {\n        yield value;\n        return;\n    }\n    let offset = 0;\n    while(offset < value.byteLength){\n        const size = Math.min(value.byteLength - offset, MAX_CHUNK_SIZE);\n        const buffer = value.buffer.slice(offset, offset + size);\n        offset += buffer.byteLength;\n        yield new Uint8Array(buffer);\n    }\n}\n// src/util/getStreamIterator.ts\nasync function* readStream(readable) {\n    const reader = readable.getReader();\n    while(true){\n        const { done, value } = await reader.read();\n        if (done) {\n            break;\n        }\n        yield value;\n    }\n}\nasync function* chunkStream(stream) {\n    for await (const value of stream){\n        yield* chunk(value);\n    }\n}\nvar getStreamIterator = (source)=>{\n    if (isAsyncIterable(source)) {\n        return chunkStream(source);\n    }\n    if (isFunction(source.getReader)) {\n        return chunkStream(readStream(source));\n    }\n    throw new TypeError(\"Unsupported data source: Expected either ReadableStream or async iterable.\");\n};\n// src/util/createBoundary.ts\nvar alphabet = \"abcdefghijklmnopqrstuvwxyz0123456789\";\nfunction createBoundary() {\n    let size = 16;\n    let res = \"\";\n    while(size--){\n        res += alphabet[Math.random() * alphabet.length << 0];\n    }\n    return res;\n}\n// src/util/normalizeValue.ts\nvar normalizeValue = (value)=>String(value).replace(/\\r|\\n/g, (match, i, str)=>{\n        if (match === \"\\r\" && str[i + 1] !== \"\\n\" || match === \"\\n\" && str[i - 1] !== \"\\r\") {\n            return \"\\r\\n\";\n        }\n        return match;\n    });\n// src/util/isPlainObject.ts\nvar getType = (value)=>Object.prototype.toString.call(value).slice(8, -1).toLowerCase();\nfunction isPlainObject(value) {\n    if (getType(value) !== \"object\") {\n        return false;\n    }\n    const pp = Object.getPrototypeOf(value);\n    if (pp === null || pp === void 0) {\n        return true;\n    }\n    const Ctor = pp.constructor && pp.constructor.toString();\n    return Ctor === Object.toString();\n}\n// src/util/proxyHeaders.ts\nfunction getProperty(target, prop) {\n    if (typeof prop === \"string\") {\n        for (const [name, value] of Object.entries(target)){\n            if (prop.toLowerCase() === name.toLowerCase()) {\n                return value;\n            }\n        }\n    }\n    return void 0;\n}\nvar proxyHeaders = (object)=>new Proxy(object, {\n        get: (target, prop)=>getProperty(target, prop),\n        has: (target, prop)=>getProperty(target, prop) !== void 0\n    });\n// src/util/isFormData.ts\nvar isFormData = (value)=>Boolean(value && isFunction(value.constructor) && value[Symbol.toStringTag] === \"FormData\" && isFunction(value.append) && isFunction(value.getAll) && isFunction(value.entries) && isFunction(value[Symbol.iterator]));\n// src/util/escapeName.ts\nvar escapeName = (name)=>String(name).replace(/\\r/g, \"%0D\").replace(/\\n/g, \"%0A\").replace(/\"/g, \"%22\");\n// src/util/isFile.ts\nvar isFile = (value)=>Boolean(value && typeof value === \"object\" && isFunction(value.constructor) && value[Symbol.toStringTag] === \"File\" && isFunction(value.stream) && value.name != null);\n// src/FormDataEncoder.ts\nvar defaultOptions = {\n    enableAdditionalHeaders: false\n};\nvar readonlyProp = {\n    writable: false,\n    configurable: false\n};\nvar _CRLF, _CRLF_BYTES, _CRLF_BYTES_LENGTH, _DASHES, _encoder, _footer, _form, _options, _getFieldHeader, getFieldHeader_fn, _getContentLength, getContentLength_fn;\nvar FormDataEncoder = class {\n    constructor(form, boundaryOrOptions, options){\n        __privateAdd(this, _getFieldHeader);\n        /**\n     * Returns form-data content length\n     */ __privateAdd(this, _getContentLength);\n        __privateAdd(this, _CRLF, \"\\r\\n\");\n        __privateAdd(this, _CRLF_BYTES, void 0);\n        __privateAdd(this, _CRLF_BYTES_LENGTH, void 0);\n        __privateAdd(this, _DASHES, \"-\".repeat(2));\n        /**\n     * TextEncoder instance\n     */ __privateAdd(this, _encoder, new TextEncoder());\n        /**\n     * Returns form-data footer bytes\n     */ __privateAdd(this, _footer, void 0);\n        /**\n     * FormData instance\n     */ __privateAdd(this, _form, void 0);\n        /**\n     * Instance options\n     */ __privateAdd(this, _options, void 0);\n        if (!isFormData(form)) {\n            throw new TypeError(\"Expected first argument to be a FormData instance.\");\n        }\n        let boundary;\n        if (isPlainObject(boundaryOrOptions)) {\n            options = boundaryOrOptions;\n        } else {\n            boundary = boundaryOrOptions;\n        }\n        if (!boundary) {\n            boundary = createBoundary();\n        }\n        if (typeof boundary !== \"string\") {\n            throw new TypeError(\"Expected boundary argument to be a string.\");\n        }\n        if (options && !isPlainObject(options)) {\n            throw new TypeError(\"Expected options argument to be an object.\");\n        }\n        __privateSet(this, _form, Array.from(form.entries()));\n        __privateSet(this, _options, {\n            ...defaultOptions,\n            ...options\n        });\n        __privateSet(this, _CRLF_BYTES, __privateGet(this, _encoder).encode(__privateGet(this, _CRLF)));\n        __privateSet(this, _CRLF_BYTES_LENGTH, __privateGet(this, _CRLF_BYTES).byteLength);\n        this.boundary = `form-data-boundary-${boundary}`;\n        this.contentType = `multipart/form-data; boundary=${this.boundary}`;\n        __privateSet(this, _footer, __privateGet(this, _encoder).encode(`${__privateGet(this, _DASHES)}${this.boundary}${__privateGet(this, _DASHES)}${__privateGet(this, _CRLF).repeat(2)}`));\n        const headers = {\n            \"Content-Type\": this.contentType\n        };\n        const contentLength = __privateMethod(this, _getContentLength, getContentLength_fn).call(this);\n        if (contentLength) {\n            this.contentLength = contentLength;\n            headers[\"Content-Length\"] = contentLength;\n        }\n        this.headers = proxyHeaders(Object.freeze(headers));\n        Object.defineProperties(this, {\n            boundary: readonlyProp,\n            contentType: readonlyProp,\n            contentLength: readonlyProp,\n            headers: readonlyProp\n        });\n    }\n    /**\n   * Creates an iterator allowing to go through form-data parts (with metadata).\n   * This method **will not** read the files and **will not** split values big into smaller chunks.\n   *\n   * Using this method, you can convert form-data content into Blob:\n   *\n   * @example\n   *\n   * ```ts\n   * import {Readable} from \"stream\"\n   *\n   * import {FormDataEncoder} from \"form-data-encoder\"\n   *\n   * import {FormData} from \"formdata-polyfill/esm-min.js\"\n   * import {fileFrom} from \"fetch-blob/form.js\"\n   * import {File} from \"fetch-blob/file.js\"\n   * import {Blob} from \"fetch-blob\"\n   *\n   * import fetch from \"node-fetch\"\n   *\n   * const form = new FormData()\n   *\n   * form.set(\"field\", \"Just a random string\")\n   * form.set(\"file\", new File([\"Using files is class amazing\"]))\n   * form.set(\"fileFromPath\", await fileFrom(\"path/to/a/file.txt\"))\n   *\n   * const encoder = new FormDataEncoder(form)\n   *\n   * const options = {\n   *   method: \"post\",\n   *   body: new Blob(encoder, {type: encoder.contentType})\n   * }\n   *\n   * const response = await fetch(\"https://httpbin.org/post\", options)\n   *\n   * console.log(await response.json())\n   * ```\n   */ *values() {\n        for (const [name, raw] of __privateGet(this, _form)){\n            const value = isFile(raw) ? raw : __privateGet(this, _encoder).encode(normalizeValue(raw));\n            yield __privateMethod(this, _getFieldHeader, getFieldHeader_fn).call(this, name, value);\n            yield value;\n            yield __privateGet(this, _CRLF_BYTES);\n        }\n        yield __privateGet(this, _footer);\n    }\n    /**\n   * Creates an async iterator allowing to perform the encoding by portions.\n   * This method reads through files and splits big values into smaller pieces (65536 bytes per each).\n   *\n   * @example\n   *\n   * ```ts\n   * import {Readable} from \"stream\"\n   *\n   * import {FormData, File, fileFromPath} from \"formdata-node\"\n   * import {FormDataEncoder} from \"form-data-encoder\"\n   *\n   * import fetch from \"node-fetch\"\n   *\n   * const form = new FormData()\n   *\n   * form.set(\"field\", \"Just a random string\")\n   * form.set(\"file\", new File([\"Using files is class amazing\"], \"file.txt\"))\n   * form.set(\"fileFromPath\", await fileFromPath(\"path/to/a/file.txt\"))\n   *\n   * const encoder = new FormDataEncoder(form)\n   *\n   * const options = {\n   *   method: \"post\",\n   *   headers: encoder.headers,\n   *   body: Readable.from(encoder.encode()) // or Readable.from(encoder)\n   * }\n   *\n   * const response = await fetch(\"https://httpbin.org/post\", options)\n   *\n   * console.log(await response.json())\n   * ```\n   */ async *encode() {\n        for (const part of this.values()){\n            if (isFile(part)) {\n                yield* getStreamIterator(part.stream());\n            } else {\n                yield* chunk(part);\n            }\n        }\n    }\n    /**\n   * Creates an iterator allowing to read through the encoder data using for...of loops\n   */ [Symbol.iterator]() {\n        return this.values();\n    }\n    /**\n   * Creates an **async** iterator allowing to read through the encoder data using for-await...of loops\n   */ [Symbol.asyncIterator]() {\n        return this.encode();\n    }\n};\n_CRLF = new WeakMap();\n_CRLF_BYTES = new WeakMap();\n_CRLF_BYTES_LENGTH = new WeakMap();\n_DASHES = new WeakMap();\n_encoder = new WeakMap();\n_footer = new WeakMap();\n_form = new WeakMap();\n_options = new WeakMap();\n_getFieldHeader = new WeakSet();\ngetFieldHeader_fn = function(name, value) {\n    let header = \"\";\n    header += `${__privateGet(this, _DASHES)}${this.boundary}${__privateGet(this, _CRLF)}`;\n    header += `Content-Disposition: form-data; name=\"${escapeName(name)}\"`;\n    if (isFile(value)) {\n        header += `; filename=\"${escapeName(value.name)}\"${__privateGet(this, _CRLF)}`;\n        header += `Content-Type: ${value.type || \"application/octet-stream\"}`;\n    }\n    if (__privateGet(this, _options).enableAdditionalHeaders === true) {\n        const size = isFile(value) ? value.size : value.byteLength;\n        if (size != null && !isNaN(size)) {\n            header += `${__privateGet(this, _CRLF)}Content-Length: ${size}`;\n        }\n    }\n    return __privateGet(this, _encoder).encode(`${header}${__privateGet(this, _CRLF).repeat(2)}`);\n};\n_getContentLength = new WeakSet();\ngetContentLength_fn = function() {\n    let length = 0;\n    for (const [name, raw] of __privateGet(this, _form)){\n        const value = isFile(raw) ? raw : __privateGet(this, _encoder).encode(normalizeValue(raw));\n        const size = isFile(value) ? value.size : value.byteLength;\n        if (size == null || isNaN(size)) {\n            return void 0;\n        }\n        length += __privateMethod(this, _getFieldHeader, getFieldHeader_fn).call(this, name, value).byteLength;\n        length += size;\n        length += __privateGet(this, _CRLF_BYTES_LENGTH);\n    }\n    return String(length + __privateGet(this, _footer).byteLength);\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZm9ybS1kYXRhLWVuY29kZXIvbGliL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLFlBQVlDLE9BQU9DLGNBQWM7QUFDckMsSUFBSUMsbUJBQW1CRixPQUFPRyx3QkFBd0I7QUFDdEQsSUFBSUMsb0JBQW9CSixPQUFPSyxtQkFBbUI7QUFDbEQsSUFBSUMsZUFBZU4sT0FBT08sU0FBUyxDQUFDQyxjQUFjO0FBQ2xELElBQUlDLFdBQVcsQ0FBQ0MsUUFBUUM7SUFDdEIsSUFBSyxJQUFJQyxRQUFRRCxJQUNmWixVQUFVVyxRQUFRRSxNQUFNO1FBQUVDLEtBQUtGLEdBQUcsQ0FBQ0MsS0FBSztRQUFFRSxZQUFZO0lBQUs7QUFDL0Q7QUFDQSxJQUFJQyxjQUFjLENBQUNDLElBQUlDLE1BQU1DLFFBQVFDO0lBQ25DLElBQUlGLFFBQVEsT0FBT0EsU0FBUyxZQUFZLE9BQU9BLFNBQVMsWUFBWTtRQUNsRSxLQUFLLElBQUlHLE9BQU9oQixrQkFBa0JhLE1BQ2hDLElBQUksQ0FBQ1gsYUFBYWUsSUFBSSxDQUFDTCxJQUFJSSxRQUFRQSxRQUFRRixRQUN6Q25CLFVBQVVpQixJQUFJSSxLQUFLO1lBQUVQLEtBQUssSUFBTUksSUFBSSxDQUFDRyxJQUFJO1lBQUVOLFlBQVksQ0FBRUssQ0FBQUEsT0FBT2pCLGlCQUFpQmUsTUFBTUcsSUFBRyxLQUFNRCxLQUFLTCxVQUFVO1FBQUM7SUFDdEg7SUFDQSxPQUFPRTtBQUNUO0FBQ0EsSUFBSU0sZUFBZSxDQUFDQyxNQUFRUixZQUFZaEIsVUFBVSxDQUFDLEdBQUcsY0FBYztRQUFFeUIsT0FBTztJQUFLLElBQUlEO0FBQ3RGLElBQUlFLGdCQUFnQixDQUFDQyxLQUFLQyxRQUFRQztJQUNoQyxJQUFJLENBQUNELE9BQU9FLEdBQUcsQ0FBQ0gsTUFDZCxNQUFNSSxVQUFVLFlBQVlGO0FBQ2hDO0FBQ0EsSUFBSUcsZUFBZSxDQUFDTCxLQUFLQyxRQUFRSztJQUMvQlAsY0FBY0Ms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NkIsVUFBVTtRQUN0R3NCLFVBQVVwQjtRQUNWb0IsVUFBVTVDLGFBQWEsSUFBSSxFQUFFOEU7SUFDL0I7SUFDQSxPQUFPaEMsT0FBT0YsU0FBUzVDLGFBQWEsSUFBSSxFQUFFaUYsU0FBUzNELFVBQVU7QUFDL0Q7QUFDQSw2REFBNkQ7QUFDN0QsS0FBTVIsQ0FBQUEsQ0FJTiIsInNvdXJjZXMiOlsid2VicGFjazovL2FzaXN0ZW50ZS12aXJ0dWFsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2Zvcm0tZGF0YS1lbmNvZGVyL2xpYi9pbmRleC5janM/ZmY2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgX19hY2Nlc3NDaGVjayA9IChvYmosIG1lbWJlciwgbXNnKSA9PiB7XG4gIGlmICghbWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG59O1xudmFyIF9fcHJpdmF0ZUdldCA9IChvYmosIG1lbWJlciwgZ2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIik7XG4gIHJldHVybiBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogbWVtYmVyLmdldChvYmopO1xufTtcbnZhciBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiB7XG4gIGlmIChtZW1iZXIuaGFzKG9iaikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZVwiKTtcbiAgbWVtYmVyIGluc3RhbmNlb2YgV2Vha1NldCA/IG1lbWJlci5hZGQob2JqKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG59O1xudmFyIF9fcHJpdmF0ZVNldCA9IChvYmosIG1lbWJlciwgdmFsdWUsIHNldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIik7XG4gIHNldHRlciA/IHNldHRlci5jYWxsKG9iaiwgdmFsdWUpIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBfX3ByaXZhdGVNZXRob2QgPSAob2JqLCBtZW1iZXIsIG1ldGhvZCkgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcImFjY2VzcyBwcml2YXRlIG1ldGhvZFwiKTtcbiAgcmV0dXJuIG1ldGhvZDtcbn07XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIHNyY19leHBvcnRzID0ge307XG5fX2V4cG9ydChzcmNfZXhwb3J0cywge1xuICBGb3JtRGF0YUVuY29kZXI6ICgpID0+IEZvcm1EYXRhRW5jb2RlcixcbiAgaXNGaWxlOiAoKSA9PiBpc0ZpbGUsXG4gIGlzRm9ybURhdGE6ICgpID0+IGlzRm9ybURhdGFcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoc3JjX2V4cG9ydHMpO1xuXG4vLyBzcmMvdXRpbC9pc0Z1bmN0aW9uLnRzXG52YXIgaXNGdW5jdGlvbiA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG5cbi8vIHNyYy91dGlsL2lzQXN5bmNJdGVyYWJsZS50c1xudmFyIGlzQXN5bmNJdGVyYWJsZSA9ICh2YWx1ZSkgPT4gaXNGdW5jdGlvbih2YWx1ZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0pO1xuXG4vLyBzcmMvdXRpbC9jaHVuay50c1xudmFyIE1BWF9DSFVOS19TSVpFID0gNjU1MzY7XG5mdW5jdGlvbiogY2h1bmsodmFsdWUpIHtcbiAgaWYgKHZhbHVlLmJ5dGVMZW5ndGggPD0gTUFYX0NIVU5LX1NJWkUpIHtcbiAgICB5aWVsZCB2YWx1ZTtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IG9mZnNldCA9IDA7XG4gIHdoaWxlIChvZmZzZXQgPCB2YWx1ZS5ieXRlTGVuZ3RoKSB7XG4gICAgY29uc3Qgc2l6ZSA9IE1hdGgubWluKHZhbHVlLmJ5dGVMZW5ndGggLSBvZmZzZXQsIE1BWF9DSFVOS19TSVpFKTtcbiAgICBjb25zdCBidWZmZXIgPSB2YWx1ZS5idWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzaXplKTtcbiAgICBvZmZzZXQgKz0gYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgeWllbGQgbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbC9nZXRTdHJlYW1JdGVyYXRvci50c1xuYXN5bmMgZnVuY3Rpb24qIHJlYWRTdHJlYW0ocmVhZGFibGUpIHtcbiAgY29uc3QgcmVhZGVyID0gcmVhZGFibGUuZ2V0UmVhZGVyKCk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHlpZWxkIHZhbHVlO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiogY2h1bmtTdHJlYW0oc3RyZWFtKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2Ygc3RyZWFtKSB7XG4gICAgeWllbGQqIGNodW5rKHZhbHVlKTtcbiAgfVxufVxudmFyIGdldFN0cmVhbUl0ZXJhdG9yID0gKHNvdXJjZSkgPT4ge1xuICBpZiAoaXNBc3luY0l0ZXJhYmxlKHNvdXJjZSkpIHtcbiAgICByZXR1cm4gY2h1bmtTdHJlYW0oc291cmNlKTtcbiAgfVxuICBpZiAoaXNGdW5jdGlvbihzb3VyY2UuZ2V0UmVhZGVyKSkge1xuICAgIHJldHVybiBjaHVua1N0cmVhbShyZWFkU3RyZWFtKHNvdXJjZSkpO1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgXCJVbnN1cHBvcnRlZCBkYXRhIHNvdXJjZTogRXhwZWN0ZWQgZWl0aGVyIFJlYWRhYmxlU3RyZWFtIG9yIGFzeW5jIGl0ZXJhYmxlLlwiXG4gICk7XG59O1xuXG4vLyBzcmMvdXRpbC9jcmVhdGVCb3VuZGFyeS50c1xudmFyIGFscGhhYmV0ID0gXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODlcIjtcbmZ1bmN0aW9uIGNyZWF0ZUJvdW5kYXJ5KCkge1xuICBsZXQgc2l6ZSA9IDE2O1xuICBsZXQgcmVzID0gXCJcIjtcbiAgd2hpbGUgKHNpemUtLSkge1xuICAgIHJlcyArPSBhbHBoYWJldFtNYXRoLnJhbmRvbSgpICogYWxwaGFiZXQubGVuZ3RoIDw8IDBdO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy91dGlsL25vcm1hbGl6ZVZhbHVlLnRzXG52YXIgbm9ybWFsaXplVmFsdWUgPSAodmFsdWUpID0+IFN0cmluZyh2YWx1ZSkucmVwbGFjZSgvXFxyfFxcbi9nLCAobWF0Y2gsIGksIHN0cikgPT4ge1xuICBpZiAobWF0Y2ggPT09IFwiXFxyXCIgJiYgc3RyW2kgKyAxXSAhPT0gXCJcXG5cIiB8fCBtYXRjaCA9PT0gXCJcXG5cIiAmJiBzdHJbaSAtIDFdICE9PSBcIlxcclwiKSB7XG4gICAgcmV0dXJuIFwiXFxyXFxuXCI7XG4gIH1cbiAgcmV0dXJuIG1hdGNoO1xufSk7XG5cbi8vIHNyYy91dGlsL2lzUGxhaW5PYmplY3QudHNcbnZhciBnZXRUeXBlID0gKHZhbHVlKSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpO1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoZ2V0VHlwZSh2YWx1ZSkgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgcHAgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICBpZiAocHAgPT09IG51bGwgfHwgcHAgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IEN0b3IgPSBwcC5jb25zdHJ1Y3RvciAmJiBwcC5jb25zdHJ1Y3Rvci50b1N0cmluZygpO1xuICByZXR1cm4gQ3RvciA9PT0gT2JqZWN0LnRvU3RyaW5nKCk7XG59XG5cbi8vIHNyYy91dGlsL3Byb3h5SGVhZGVycy50c1xuZnVuY3Rpb24gZ2V0UHJvcGVydHkodGFyZ2V0LCBwcm9wKSB7XG4gIGlmICh0eXBlb2YgcHJvcCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0YXJnZXQpKSB7XG4gICAgICBpZiAocHJvcC50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxudmFyIHByb3h5SGVhZGVycyA9IChvYmplY3QpID0+IG5ldyBQcm94eShcbiAgb2JqZWN0LFxuICB7XG4gICAgZ2V0OiAodGFyZ2V0LCBwcm9wKSA9PiBnZXRQcm9wZXJ0eSh0YXJnZXQsIHByb3ApLFxuICAgIGhhczogKHRhcmdldCwgcHJvcCkgPT4gZ2V0UHJvcGVydHkodGFyZ2V0LCBwcm9wKSAhPT0gdm9pZCAwXG4gIH1cbik7XG5cbi8vIHNyYy91dGlsL2lzRm9ybURhdGEudHNcbnZhciBpc0Zvcm1EYXRhID0gKHZhbHVlKSA9PiBCb29sZWFuKFxuICB2YWx1ZSAmJiBpc0Z1bmN0aW9uKHZhbHVlLmNvbnN0cnVjdG9yKSAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSBcIkZvcm1EYXRhXCIgJiYgaXNGdW5jdGlvbih2YWx1ZS5hcHBlbmQpICYmIGlzRnVuY3Rpb24odmFsdWUuZ2V0QWxsKSAmJiBpc0Z1bmN0aW9uKHZhbHVlLmVudHJpZXMpICYmIGlzRnVuY3Rpb24odmFsdWVbU3ltYm9sLml0ZXJhdG9yXSlcbik7XG5cbi8vIHNyYy91dGlsL2VzY2FwZU5hbWUudHNcbnZhciBlc2NhcGVOYW1lID0gKG5hbWUpID0+IFN0cmluZyhuYW1lKS5yZXBsYWNlKC9cXHIvZywgXCIlMERcIikucmVwbGFjZSgvXFxuL2csIFwiJTBBXCIpLnJlcGxhY2UoL1wiL2csIFwiJTIyXCIpO1xuXG4vLyBzcmMvdXRpbC9pc0ZpbGUudHNcbnZhciBpc0ZpbGUgPSAodmFsdWUpID0+IEJvb2xlYW4oXG4gIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBpc0Z1bmN0aW9uKHZhbHVlLmNvbnN0cnVjdG9yKSAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSBcIkZpbGVcIiAmJiBpc0Z1bmN0aW9uKHZhbHVlLnN0cmVhbSkgJiYgdmFsdWUubmFtZSAhPSBudWxsXG4pO1xuXG4vLyBzcmMvRm9ybURhdGFFbmNvZGVyLnRzXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGVuYWJsZUFkZGl0aW9uYWxIZWFkZXJzOiBmYWxzZVxufTtcbnZhciByZWFkb25seVByb3AgPSB7IHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiBmYWxzZSB9O1xudmFyIF9DUkxGLCBfQ1JMRl9CWVRFUywgX0NSTEZfQllURVNfTEVOR1RILCBfREFTSEVTLCBfZW5jb2RlciwgX2Zvb3RlciwgX2Zvcm0sIF9vcHRpb25zLCBfZ2V0RmllbGRIZWFkZXIsIGdldEZpZWxkSGVhZGVyX2ZuLCBfZ2V0Q29udGVudExlbmd0aCwgZ2V0Q29udGVudExlbmd0aF9mbjtcbnZhciBGb3JtRGF0YUVuY29kZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGZvcm0sIGJvdW5kYXJ5T3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9nZXRGaWVsZEhlYWRlcik7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBmb3JtLWRhdGEgY29udGVudCBsZW5ndGhcbiAgICAgKi9cbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2dldENvbnRlbnRMZW5ndGgpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfQ1JMRiwgXCJcXHJcXG5cIik7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9DUkxGX0JZVEVTLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfQ1JMRl9CWVRFU19MRU5HVEgsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9EQVNIRVMsIFwiLVwiLnJlcGVhdCgyKSk7XG4gICAgLyoqXG4gICAgICogVGV4dEVuY29kZXIgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2VuY29kZXIsIG5ldyBUZXh0RW5jb2RlcigpKTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGZvcm0tZGF0YSBmb290ZXIgYnl0ZXNcbiAgICAgKi9cbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2Zvb3Rlciwgdm9pZCAwKTtcbiAgICAvKipcbiAgICAgKiBGb3JtRGF0YSBpbnN0YW5jZVxuICAgICAqL1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZm9ybSwgdm9pZCAwKTtcbiAgICAvKipcbiAgICAgKiBJbnN0YW5jZSBvcHRpb25zXG4gICAgICovXG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9vcHRpb25zLCB2b2lkIDApO1xuICAgIGlmICghaXNGb3JtRGF0YShmb3JtKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGEgRm9ybURhdGEgaW5zdGFuY2UuXCIpO1xuICAgIH1cbiAgICBsZXQgYm91bmRhcnk7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoYm91bmRhcnlPck9wdGlvbnMpKSB7XG4gICAgICBvcHRpb25zID0gYm91bmRhcnlPck9wdGlvbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvdW5kYXJ5ID0gYm91bmRhcnlPck9wdGlvbnM7XG4gICAgfVxuICAgIGlmICghYm91bmRhcnkpIHtcbiAgICAgIGJvdW5kYXJ5ID0gY3JlYXRlQm91bmRhcnkoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBib3VuZGFyeSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGJvdW5kYXJ5IGFyZ3VtZW50IHRvIGJlIGEgc3RyaW5nLlwiKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgJiYgIWlzUGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBvcHRpb25zIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdC5cIik7XG4gICAgfVxuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfZm9ybSwgQXJyYXkuZnJvbShmb3JtLmVudHJpZXMoKSkpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfb3B0aW9ucywgeyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9KTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX0NSTEZfQllURVMsIF9fcHJpdmF0ZUdldCh0aGlzLCBfZW5jb2RlcikuZW5jb2RlKF9fcHJpdmF0ZUdldCh0aGlzLCBfQ1JMRikpKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX0NSTEZfQllURVNfTEVOR1RILCBfX3ByaXZhdGVHZXQodGhpcywgX0NSTEZfQllURVMpLmJ5dGVMZW5ndGgpO1xuICAgIHRoaXMuYm91bmRhcnkgPSBgZm9ybS1kYXRhLWJvdW5kYXJ5LSR7Ym91bmRhcnl9YDtcbiAgICB0aGlzLmNvbnRlbnRUeXBlID0gYG11bHRpcGFydC9mb3JtLWRhdGE7IGJvdW5kYXJ5PSR7dGhpcy5ib3VuZGFyeX1gO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfZm9vdGVyLCBfX3ByaXZhdGVHZXQodGhpcywgX2VuY29kZXIpLmVuY29kZShcbiAgICAgIGAke19fcHJpdmF0ZUdldCh0aGlzLCBfREFTSEVTKX0ke3RoaXMuYm91bmRhcnl9JHtfX3ByaXZhdGVHZXQodGhpcywgX0RBU0hFUyl9JHtfX3ByaXZhdGVHZXQodGhpcywgX0NSTEYpLnJlcGVhdCgyKX1gXG4gICAgKSk7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IHRoaXMuY29udGVudFR5cGVcbiAgICB9O1xuICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBfX3ByaXZhdGVNZXRob2QodGhpcywgX2dldENvbnRlbnRMZW5ndGgsIGdldENvbnRlbnRMZW5ndGhfZm4pLmNhbGwodGhpcyk7XG4gICAgaWYgKGNvbnRlbnRMZW5ndGgpIHtcbiAgICAgIHRoaXMuY29udGVudExlbmd0aCA9IGNvbnRlbnRMZW5ndGg7XG4gICAgICBoZWFkZXJzW1wiQ29udGVudC1MZW5ndGhcIl0gPSBjb250ZW50TGVuZ3RoO1xuICAgIH1cbiAgICB0aGlzLmhlYWRlcnMgPSBwcm94eUhlYWRlcnMoT2JqZWN0LmZyZWV6ZShoZWFkZXJzKSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgYm91bmRhcnk6IHJlYWRvbmx5UHJvcCxcbiAgICAgIGNvbnRlbnRUeXBlOiByZWFkb25seVByb3AsXG4gICAgICBjb250ZW50TGVuZ3RoOiByZWFkb25seVByb3AsXG4gICAgICBoZWFkZXJzOiByZWFkb25seVByb3BcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpdGVyYXRvciBhbGxvd2luZyB0byBnbyB0aHJvdWdoIGZvcm0tZGF0YSBwYXJ0cyAod2l0aCBtZXRhZGF0YSkuXG4gICAqIFRoaXMgbWV0aG9kICoqd2lsbCBub3QqKiByZWFkIHRoZSBmaWxlcyBhbmQgKip3aWxsIG5vdCoqIHNwbGl0IHZhbHVlcyBiaWcgaW50byBzbWFsbGVyIGNodW5rcy5cbiAgICpcbiAgICogVXNpbmcgdGhpcyBtZXRob2QsIHlvdSBjYW4gY29udmVydCBmb3JtLWRhdGEgY29udGVudCBpbnRvIEJsb2I6XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYHRzXG4gICAqIGltcG9ydCB7UmVhZGFibGV9IGZyb20gXCJzdHJlYW1cIlxuICAgKlxuICAgKiBpbXBvcnQge0Zvcm1EYXRhRW5jb2Rlcn0gZnJvbSBcImZvcm0tZGF0YS1lbmNvZGVyXCJcbiAgICpcbiAgICogaW1wb3J0IHtGb3JtRGF0YX0gZnJvbSBcImZvcm1kYXRhLXBvbHlmaWxsL2VzbS1taW4uanNcIlxuICAgKiBpbXBvcnQge2ZpbGVGcm9tfSBmcm9tIFwiZmV0Y2gtYmxvYi9mb3JtLmpzXCJcbiAgICogaW1wb3J0IHtGaWxlfSBmcm9tIFwiZmV0Y2gtYmxvYi9maWxlLmpzXCJcbiAgICogaW1wb3J0IHtCbG9ifSBmcm9tIFwiZmV0Y2gtYmxvYlwiXG4gICAqXG4gICAqIGltcG9ydCBmZXRjaCBmcm9tIFwibm9kZS1mZXRjaFwiXG4gICAqXG4gICAqIGNvbnN0IGZvcm0gPSBuZXcgRm9ybURhdGEoKVxuICAgKlxuICAgKiBmb3JtLnNldChcImZpZWxkXCIsIFwiSnVzdCBhIHJhbmRvbSBzdHJpbmdcIilcbiAgICogZm9ybS5zZXQoXCJmaWxlXCIsIG5ldyBGaWxlKFtcIlVzaW5nIGZpbGVzIGlzIGNsYXNzIGFtYXppbmdcIl0pKVxuICAgKiBmb3JtLnNldChcImZpbGVGcm9tUGF0aFwiLCBhd2FpdCBmaWxlRnJvbShcInBhdGgvdG8vYS9maWxlLnR4dFwiKSlcbiAgICpcbiAgICogY29uc3QgZW5jb2RlciA9IG5ldyBGb3JtRGF0YUVuY29kZXIoZm9ybSlcbiAgICpcbiAgICogY29uc3Qgb3B0aW9ucyA9IHtcbiAgICogICBtZXRob2Q6IFwicG9zdFwiLFxuICAgKiAgIGJvZHk6IG5ldyBCbG9iKGVuY29kZXIsIHt0eXBlOiBlbmNvZGVyLmNvbnRlbnRUeXBlfSlcbiAgICogfVxuICAgKlxuICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiaHR0cHM6Ly9odHRwYmluLm9yZy9wb3N0XCIsIG9wdGlvbnMpXG4gICAqXG4gICAqIGNvbnNvbGUubG9nKGF3YWl0IHJlc3BvbnNlLmpzb24oKSlcbiAgICogYGBgXG4gICAqL1xuICAqdmFsdWVzKCkge1xuICAgIGZvciAoY29uc3QgW25hbWUsIHJhd10gb2YgX19wcml2YXRlR2V0KHRoaXMsIF9mb3JtKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBpc0ZpbGUocmF3KSA/IHJhdyA6IF9fcHJpdmF0ZUdldCh0aGlzLCBfZW5jb2RlcikuZW5jb2RlKFxuICAgICAgICBub3JtYWxpemVWYWx1ZShyYXcpXG4gICAgICApO1xuICAgICAgeWllbGQgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9nZXRGaWVsZEhlYWRlciwgZ2V0RmllbGRIZWFkZXJfZm4pLmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgeWllbGQgdmFsdWU7XG4gICAgICB5aWVsZCBfX3ByaXZhdGVHZXQodGhpcywgX0NSTEZfQllURVMpO1xuICAgIH1cbiAgICB5aWVsZCBfX3ByaXZhdGVHZXQodGhpcywgX2Zvb3Rlcik7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXN5bmMgaXRlcmF0b3IgYWxsb3dpbmcgdG8gcGVyZm9ybSB0aGUgZW5jb2RpbmcgYnkgcG9ydGlvbnMuXG4gICAqIFRoaXMgbWV0aG9kIHJlYWRzIHRocm91Z2ggZmlsZXMgYW5kIHNwbGl0cyBiaWcgdmFsdWVzIGludG8gc21hbGxlciBwaWVjZXMgKDY1NTM2IGJ5dGVzIHBlciBlYWNoKS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IHtSZWFkYWJsZX0gZnJvbSBcInN0cmVhbVwiXG4gICAqXG4gICAqIGltcG9ydCB7Rm9ybURhdGEsIEZpbGUsIGZpbGVGcm9tUGF0aH0gZnJvbSBcImZvcm1kYXRhLW5vZGVcIlxuICAgKiBpbXBvcnQge0Zvcm1EYXRhRW5jb2Rlcn0gZnJvbSBcImZvcm0tZGF0YS1lbmNvZGVyXCJcbiAgICpcbiAgICogaW1wb3J0IGZldGNoIGZyb20gXCJub2RlLWZldGNoXCJcbiAgICpcbiAgICogY29uc3QgZm9ybSA9IG5ldyBGb3JtRGF0YSgpXG4gICAqXG4gICAqIGZvcm0uc2V0KFwiZmllbGRcIiwgXCJKdXN0IGEgcmFuZG9tIHN0cmluZ1wiKVxuICAgKiBmb3JtLnNldChcImZpbGVcIiwgbmV3IEZpbGUoW1wiVXNpbmcgZmlsZXMgaXMgY2xhc3MgYW1hemluZ1wiXSwgXCJmaWxlLnR4dFwiKSlcbiAgICogZm9ybS5zZXQoXCJmaWxlRnJvbVBhdGhcIiwgYXdhaXQgZmlsZUZyb21QYXRoKFwicGF0aC90by9hL2ZpbGUudHh0XCIpKVxuICAgKlxuICAgKiBjb25zdCBlbmNvZGVyID0gbmV3IEZvcm1EYXRhRW5jb2Rlcihmb3JtKVxuICAgKlxuICAgKiBjb25zdCBvcHRpb25zID0ge1xuICAgKiAgIG1ldGhvZDogXCJwb3N0XCIsXG4gICAqICAgaGVhZGVyczogZW5jb2Rlci5oZWFkZXJzLFxuICAgKiAgIGJvZHk6IFJlYWRhYmxlLmZyb20oZW5jb2Rlci5lbmNvZGUoKSkgLy8gb3IgUmVhZGFibGUuZnJvbShlbmNvZGVyKVxuICAgKiB9XG4gICAqXG4gICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCJodHRwczovL2h0dHBiaW4ub3JnL3Bvc3RcIiwgb3B0aW9ucylcbiAgICpcbiAgICogY29uc29sZS5sb2coYXdhaXQgcmVzcG9uc2UuanNvbigpKVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jICplbmNvZGUoKSB7XG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIHRoaXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChpc0ZpbGUocGFydCkpIHtcbiAgICAgICAgeWllbGQqIGdldFN0cmVhbUl0ZXJhdG9yKHBhcnQuc3RyZWFtKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWllbGQqIGNodW5rKHBhcnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpdGVyYXRvciBhbGxvd2luZyB0byByZWFkIHRocm91Z2ggdGhlIGVuY29kZXIgZGF0YSB1c2luZyBmb3IuLi5vZiBsb29wc1xuICAgKi9cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gKiphc3luYyoqIGl0ZXJhdG9yIGFsbG93aW5nIHRvIHJlYWQgdGhyb3VnaCB0aGUgZW5jb2RlciBkYXRhIHVzaW5nIGZvci1hd2FpdC4uLm9mIGxvb3BzXG4gICAqL1xuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLmVuY29kZSgpO1xuICB9XG59O1xuX0NSTEYgPSBuZXcgV2Vha01hcCgpO1xuX0NSTEZfQllURVMgPSBuZXcgV2Vha01hcCgpO1xuX0NSTEZfQllURVNfTEVOR1RIID0gbmV3IFdlYWtNYXAoKTtcbl9EQVNIRVMgPSBuZXcgV2Vha01hcCgpO1xuX2VuY29kZXIgPSBuZXcgV2Vha01hcCgpO1xuX2Zvb3RlciA9IG5ldyBXZWFrTWFwKCk7XG5fZm9ybSA9IG5ldyBXZWFrTWFwKCk7XG5fb3B0aW9ucyA9IG5ldyBXZWFrTWFwKCk7XG5fZ2V0RmllbGRIZWFkZXIgPSBuZXcgV2Vha1NldCgpO1xuZ2V0RmllbGRIZWFkZXJfZm4gPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICBsZXQgaGVhZGVyID0gXCJcIjtcbiAgaGVhZGVyICs9IGAke19fcHJpdmF0ZUdldCh0aGlzLCBfREFTSEVTKX0ke3RoaXMuYm91bmRhcnl9JHtfX3ByaXZhdGVHZXQodGhpcywgX0NSTEYpfWA7XG4gIGhlYWRlciArPSBgQ29udGVudC1EaXNwb3NpdGlvbjogZm9ybS1kYXRhOyBuYW1lPVwiJHtlc2NhcGVOYW1lKG5hbWUpfVwiYDtcbiAgaWYgKGlzRmlsZSh2YWx1ZSkpIHtcbiAgICBoZWFkZXIgKz0gYDsgZmlsZW5hbWU9XCIke2VzY2FwZU5hbWUodmFsdWUubmFtZSl9XCIke19fcHJpdmF0ZUdldCh0aGlzLCBfQ1JMRil9YDtcbiAgICBoZWFkZXIgKz0gYENvbnRlbnQtVHlwZTogJHt2YWx1ZS50eXBlIHx8IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJ9YDtcbiAgfVxuICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9vcHRpb25zKS5lbmFibGVBZGRpdGlvbmFsSGVhZGVycyA9PT0gdHJ1ZSkge1xuICAgIGNvbnN0IHNpemUgPSBpc0ZpbGUodmFsdWUpID8gdmFsdWUuc2l6ZSA6IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgaWYgKHNpemUgIT0gbnVsbCAmJiAhaXNOYU4oc2l6ZSkpIHtcbiAgICAgIGhlYWRlciArPSBgJHtfX3ByaXZhdGVHZXQodGhpcywgX0NSTEYpfUNvbnRlbnQtTGVuZ3RoOiAke3NpemV9YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfZW5jb2RlcikuZW5jb2RlKGAke2hlYWRlcn0ke19fcHJpdmF0ZUdldCh0aGlzLCBfQ1JMRikucmVwZWF0KDIpfWApO1xufTtcbl9nZXRDb250ZW50TGVuZ3RoID0gbmV3IFdlYWtTZXQoKTtcbmdldENvbnRlbnRMZW5ndGhfZm4gPSBmdW5jdGlvbigpIHtcbiAgbGV0IGxlbmd0aCA9IDA7XG4gIGZvciAoY29uc3QgW25hbWUsIHJhd10gb2YgX19wcml2YXRlR2V0KHRoaXMsIF9mb3JtKSkge1xuICAgIGNvbnN0IHZhbHVlID0gaXNGaWxlKHJhdykgPyByYXcgOiBfX3ByaXZhdGVHZXQodGhpcywgX2VuY29kZXIpLmVuY29kZShcbiAgICAgIG5vcm1hbGl6ZVZhbHVlKHJhdylcbiAgICApO1xuICAgIGNvbnN0IHNpemUgPSBpc0ZpbGUodmFsdWUpID8gdmFsdWUuc2l6ZSA6IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgaWYgKHNpemUgPT0gbnVsbCB8fCBpc05hTihzaXplKSkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgbGVuZ3RoICs9IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfZ2V0RmllbGRIZWFkZXIsIGdldEZpZWxkSGVhZGVyX2ZuKS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKS5ieXRlTGVuZ3RoO1xuICAgIGxlbmd0aCArPSBzaXplO1xuICAgIGxlbmd0aCArPSBfX3ByaXZhdGVHZXQodGhpcywgX0NSTEZfQllURVNfTEVOR1RIKTtcbiAgfVxuICByZXR1cm4gU3RyaW5nKGxlbmd0aCArIF9fcHJpdmF0ZUdldCh0aGlzLCBfZm9vdGVyKS5ieXRlTGVuZ3RoKTtcbn07XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgRm9ybURhdGFFbmNvZGVyLFxuICBpc0ZpbGUsXG4gIGlzRm9ybURhdGFcbn0pO1xuIl0sIm5hbWVzIjpbIl9fZGVmUHJvcCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX19nZXRPd25Qcm9wRGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZ2V0T3duUHJvcE5hbWVzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIl9faGFzT3duUHJvcCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiX19leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZ2V0IiwiZW51bWVyYWJsZSIsIl9fY29weVByb3BzIiwidG8iLCJmcm9tIiwiZXhjZXB0IiwiZGVzYyIsImtleSIsImNhbGwiLCJfX3RvQ29tbW9uSlMiLCJtb2QiLCJ2YWx1ZSIsIl9fYWNjZXNzQ2hlY2siLCJvYmoiLCJtZW1iZXIiLCJtc2ciLCJoYXMiLCJUeXBlRXJyb3IiLCJfX3ByaXZhdGVHZXQiLCJnZXR0ZXIiLCJfX3ByaXZhdGVBZGQiLCJXZWFrU2V0IiwiYWRkIiwic2V0IiwiX19wcml2YXRlU2V0Iiwic2V0dGVyIiwiX19wcml2YXRlTWV0aG9kIiwibWV0aG9kIiwic3JjX2V4cG9ydHMiLCJGb3JtRGF0YUVuY29kZXIiLCJpc0ZpbGUiLCJpc0Zvcm1EYXRhIiwibW9kdWxlIiwiZXhwb3J0cyIsImlzRnVuY3Rpb24iLCJpc0FzeW5jSXRlcmFibGUiLCJTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwiTUFYX0NIVU5LX1NJWkUiLCJjaHVuayIsImJ5dGVMZW5ndGgiLCJvZmZzZXQiLCJzaXplIiwiTWF0aCIsIm1pbiIsImJ1ZmZlciIsInNsaWNlIiwiVWludDhBcnJheSIsInJlYWRTdHJlYW0iLCJyZWFkYWJsZSIsInJlYWRlciIsImdldFJlYWRlciIsImRvbmUiLCJyZWFkIiwiY2h1bmtTdHJlYW0iLCJzdHJlYW0iLCJnZXRTdHJlYW1JdGVyYXRvciIsInNvdXJjZSIsImFscGhhYmV0IiwiY3JlYXRlQm91bmRhcnkiLCJyZXMiLCJyYW5kb20iLCJsZW5ndGgiLCJub3JtYWxpemVWYWx1ZSIsIlN0cmluZyIsInJlcGxhY2UiLCJtYXRjaCIsImkiLCJzdHIiLCJnZXRUeXBlIiwidG9TdHJpbmciLCJ0b0xvd2VyQ2FzZSIsImlzUGxhaW5PYmplY3QiLCJwcCIsImdldFByb3RvdHlwZU9mIiwiQ3RvciIsImNvbnN0cnVjdG9yIiwiZ2V0UHJvcGVydHkiLCJwcm9wIiwiZW50cmllcyIsInByb3h5SGVhZGVycyIsIm9iamVjdCIsIlByb3h5IiwiQm9vbGVhbiIsInRvU3RyaW5nVGFnIiwiYXBwZW5kIiwiZ2V0QWxsIiwiaXRlcmF0b3IiLCJlc2NhcGVOYW1lIiwiZGVmYXVsdE9wdGlvbnMiLCJlbmFibGVBZGRpdGlvbmFsSGVhZGVycyIsInJlYWRvbmx5UHJvcCIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiX0NSTEYiLCJfQ1JMRl9CWVRFUyIsIl9DUkxGX0JZVEVTX0xFTkdUSCIsIl9EQVNIRVMiLCJfZW5jb2RlciIsIl9mb290ZXIiLCJfZm9ybSIsIl9vcHRpb25zIiwiX2dldEZpZWxkSGVhZGVyIiwiZ2V0RmllbGRIZWFkZXJfZm4iLCJfZ2V0Q29udGVudExlbmd0aCIsImdldENvbnRlbnRMZW5ndGhfZm4iLCJmb3JtIiwiYm91bmRhcnlPck9wdGlvbnMiLCJvcHRpb25zIiwicmVwZWF0IiwiVGV4dEVuY29kZXIiLCJib3VuZGFyeSIsIkFycmF5IiwiZW5jb2RlIiwiY29udGVudFR5cGUiLCJoZWFkZXJzIiwiY29udGVudExlbmd0aCIsImZyZWV6ZSIsImRlZmluZVByb3BlcnRpZXMiLCJ2YWx1ZXMiLCJyYXciLCJwYXJ0IiwiV2Vha01hcCIsImhlYWRlciIsInR5cGUiLCJpc05hTiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/form-data-encoder/lib/index.cjs\n");

/***/ })

};
;